/// Copyright (c) Pavel Kirienko

#pragma once

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C"
{
#endif

/// A sensible middle ground between worst-case gossip traffic and memory utilization vs. longest name support.
/// In CAN FD networks, topic names should not be longer than 22 bytes to avoid multi-frame heartbeats.
#define CY_TOPIC_NAME_MAX 80

/// The max namespace length should also provide space for at least one separator and the one-character topic name.
#define CY_NAMESPACE_NAME_MAX (CY_TOPIC_NAME_MAX - 2)

/// If not sure, use this value for the transfer-ID timeout.
#define CY_TFER_ID_TIMEOUT_DEFAULT_us 2000000UL

/// The recommended minimum update interval.
#define CY_UPDATE_INTERVAL_MIN_us 200000UL

#define CY_TOPIC_TTL_DEFAULT_us (3600U * 1000000UL)

/// The range of unregulated identifiers to use for CRDT topic allocation.
/// The range should be the same for all applications, so that they can all make deterministic and identical
/// subject-ID allocations even when the network is partitioned. This is not strictly necessary, but it reduces the
/// likelihood of collisions and the duration of temporary service disruptions when the network is healing after
/// de-partitioning. The range should also be as large as possible for the same reason.
///
/// Fixed topics (such as the old v1 topics with manually assigned IDs) should not be allocated in the CRDT range,
/// because old v1 nodes to not participate in the CRDT gossip, and are unable to alert the network about conflicts.
/// This problem is addressed by the occupancy mask, but it has downsides of its own (does not allow freeing topics,
/// needs 768 bytes of memory), so we prefer a simpler solution of having to force static topics into the higher IDs
/// range, in [6144, 8192).
#define CY_ALLOC_SUBJECT_COUNT 6144
#define CY_TOTAL_SUBJECT_COUNT 8192

#define CY_SUBJECT_ID_INVALID 0xFFFFU

#define CY_SUBJECT_OCCUPANCY_MASK_SIZE_BYTES ((CY_ALLOC_SUBJECT_COUNT + 7) / 8)

typedef int8_t cy_err_t;

enum cy_prio_t
{
    cy_prio_exceptional = 0,
    cy_prio_immediate   = 1,
    cy_prio_fast        = 2,
    cy_prio_high        = 3,
    cy_prio_nominal     = 4,
    cy_prio_low         = 5,
    cy_prio_slow        = 6,
    cy_prio_optional    = 7,
};

struct cy_payload_t
{
    size_t      size;
    const void* data;
};

struct cy_payload_mut_t
{
    size_t size;
    void*  data;
};

struct cy_tree_t
{
    struct cy_tree_t* up;
    struct cy_tree_t* lr[2];
    int8_t            bf;
};

struct cy_tfer_meta_t
{
    enum cy_prio_t priority;
    uint16_t       remote_node_id;
    uint64_t       tfer_id;
};

/// Returns the current monotonic time in microseconds.
typedef uint64_t (*cy_now_t)(struct cy_t*);

/// Returns a 16-bit random number. It must be likely to be unique for the given node at the given time.
/// Similar sequences generated by distinct nodes will not let the network reach consensus.
/// One way to obtain sufficiently random numbers is to use a 64-bit twister seeded with the UID.
/// TODO FIXME: this is only used to pick subject-IDs, but there is a less stochastic solution available as well,
/// based on topic CRCs.
typedef uint16_t (*cy_rand16_t)(struct cy_t*);

/// Instructs the underlying transport layer to publish a new message on the topic.
/// The function shall not increment the transfer-ID counter; Cy will do it.
/// This function is only invoked when the topic object has a valid subject-ID.
typedef cy_err_t (*cy_transport_publish_t)(struct cy_t*, struct cy_topic_t*, uint64_t, struct cy_payload_t);

/// Instructs the underlying transport layer to create a new subscription on the topic.
/// This function is only invoked when the specific subject-ID is already established, meaning
/// that the corresponding field in the topic struct is valid.
typedef cy_err_t (*cy_transport_subscribe_t)(struct cy_t*, struct cy_topic_t*);

/// Instructs the underlying transport to destroy an existing subscription.
typedef cy_err_t (*cy_transport_unsubscribe_t)(struct cy_t*, struct cy_topic_t*);

/// Internal use only.
struct cy_crdt_meta_t
{
    uint64_t owner_uid;      ///< Zero is not a valid UID.
    uint32_t lamport_clock;  ///< Starts at zero for an uninitialized entry.
};

struct cy_topic_t
{
    struct cy_tree_t index_name;
    struct cy_tree_t index_subject_id;

    /// The name is always null-terminated. We keep the size for convenience as well.
    size_t name_len;
    char   name[CY_TOPIC_NAME_MAX + 1];
    /// Assuming we have 1000 topics on the local node, the probability of a topic name hash collision is:
    /// >>> from decimal import Decimal
    /// >>> n = 1000
    /// >>> d = Decimal(2**64)
    /// >>> 1 - ((d-1)/d) ** ((n*(n-1))//2)
    /// About 2.7e-14, or one in 37 trillion.
    uint64_t name_hash;
    uint16_t name_crc;

    uint16_t subject_id;
    bool     fixed;  ///< True if the ID is assigned directly; e.g., "/7509".

    struct cy_crdt_meta_t crdt_meta;

    /// The user can use this field for arbitrary purposes.
    void* user;

    /// Only used if the application publishes data on this topic.
    /// Hint: if the application needs to detect if a topic is published to, check tfer_id>0.
    /// The priority can be adjusted as needed by the user.
    uint64_t       pub_tfer_id;
    enum cy_prio_t pub_priority;

    /// Only used if the application subscribes on this topic.
    /// Hint: if the application needs to detect if a topic is subscribed to, check sub_list!=NULL.
    struct cy_sub_t* sub_list;
    uint64_t         sub_tfer_id_timeout_us;
    size_t           sub_extent;
    bool             sub_active;
};

struct cy_sub_event_t
{
    struct cy_t*            cy;
    struct cy_topic_t*      topic;
    struct cy_sub_t*        sub;
    uint64_t                ts_us;
    struct cy_tfer_meta_t   tfer;
    struct cy_payload_mut_t payload;
};

struct cy_sub_t
{
    struct cy_sub_t* next;
    void (*callback)(const struct cy_sub_event_t*);
    void* user;
};

struct cy_t
{
    /// The UID is actually composed of 16-bit vendor-ID, 16-bit product-ID, and 32-bit instance-ID (aka serial
    /// number), arranged from the most significant to the least significant bits. However, Cy doesn't care about
    /// the inner structure of the UID; all it needs is a number to order the nodes on the network.
    /// Zero is not a valid UID.
    uint64_t uid;

    uint64_t started_at_us;

    /// The user can use this field for arbitrary purposes.
    void* user;

    // TODO FIXME: this is not really required. We can allocate topics just by looking at the subject tree.
    // If a remote node finds a collision, it will bump the allocation until it has no local conflicts;
    // every other node will keep doing it until the network agrees on the same allocation.
    //
    // The occupancy mask allows one node to quickly find a free subject-ID with a low probability of having to
    // reallocate again; however, its disadvantage is that occupancy bits are only set, but never cleared,
    // causing the free subjects to deplete over time if new topics keep appearing and disappearing.
    // Another disadvantage is that it takes 768 bytes of memory.
    //
    // The occupancy mask could allow the old v1 nodes to share the same subject-ID space with the new nodes,
    // because it could be used by subscribing to uavcan.node.port.List and then updating the mask from that message,
    // but it is probably not worth it because a better solution is available: simply segregate the subject-ID space
    // between the dynamic CRDT topics and the old fixed subject-IDs.
    uint8_t subject_occupancy_mask[CY_SUBJECT_OCCUPANCY_MASK_SIZE_BYTES];

    /// Namespace prefix added to all topics created on this instance, unless the topic name starts with "/".
    size_t namespace_len;
    char   namespace_[CY_NAMESPACE_NAME_MAX + 1];

    cy_now_t    now;
    cy_rand16_t rand16;

    /// Transport layer interface functions.
    /// These can be underpinned by libcanard, libudpard, libserard, or any other transport library.
    cy_transport_publish_t     transport_publish;
    cy_transport_subscribe_t   transport_subscribe;
    cy_transport_unsubscribe_t transport_unsubscribe;

    size_t   heartbeat_gossip_scan_index;
    uint64_t heartbeat_last_us;

    /// Topics needed by Cy itself.
    /// TODO FIXME: subscribe to the old uavcan.node.port.List to update the occupancy bitmap.
    struct cy_topic_t heartbeat_topic;
    struct cy_sub_t   heartbeat_sub;

    /// All topics are indexed both by name and by subject-ID for fast lookups.
    struct cy_tree_t* topics_by_name;
    struct cy_tree_t* topics_by_subject_id;
};

struct cy_update_event_t
{
    struct cy_topic_t*      topic;  ///< Topic associated with the transport subscription by the lib*ards.
    uint64_t                ts_us;
    struct cy_tfer_meta_t   tfer;
    uint16_t                topic_crc;  ///< TODO FIXME: Remove! Topic CRC will be managed by the lib*ards, not here!
    struct cy_payload_mut_t payload;
};

/// The namespace may be NULL or empty, in which case it defaults to "~".
/// This function will never perform any network exchanges.
cy_err_t cy_new(struct cy_t* const               cy,
                const uint64_t                   uid,
                const char* const                namespace_,
                const cy_now_t                   now,
                const cy_rand16_t                rand16,
                const cy_transport_publish_t     publish,
                const cy_transport_subscribe_t   subscribe,
                const cy_transport_unsubscribe_t unsubscribe,
                void* const                      user,
                void* const                      heartbeat_topic_user);
void     cy_destroy(struct cy_t* const cy);

/// This function shall be invoked whenever a new transfer is received;
/// if no transfers are received in approx. 200 ms, the function must be invoked with NULL topic and transfer.
/// The invocation frequency SHALL NOT be lower than 1 Hz.
cy_err_t cy_update(struct cy_t* const cy, struct cy_update_event_t* const evt);

/// When the transport library detects a topic CRC error, it will notify Cy about it to let it rectify the problem.
struct cy_subject_collision_event_t
{
    uint16_t collision_subject_id;
    uint16_t local_node_id;
    uint16_t infringing_node_id;
};
void cy_notify_subject_collision(const struct cy_subject_collision_event_t event);

/// Register a new topic that may be used by the local application for publishing, subscribing, or both.
/// Returns falsity if the topic name is not unique or not valid.
/// TODO: provide an option to restore a known subject-ID; e.g., loaded from non-volatile memory, to skip allocation?
bool cy_topic_new(struct cy_t* const cy, struct cy_topic_t* const topic, const char* const topic_name);
void cy_topic_destroy(struct cy_t* const cy, struct cy_topic_t* const topic);

inline bool cy_topic_has_local_publishers(const struct cy_topic_t* const topic)
{
    return topic->pub_tfer_id > 0;
}

inline bool cy_topic_has_local_subscribers(const struct cy_topic_t* const topic)
{
    return topic->sub_list != NULL;
}

/// Technically, the callback can be NULL, and the subscriber will work anyway.
/// One can still use the transfers from the underlying transport library before they are passed to cy_update().
///
/// Future expansion: add wildcard subscribers that match topic names by pattern. Requires unbounded dynamic memory.
///
/// Creation of a new subscription will involve network transactions unless the subject-ID is already known or is fixed.
/// However, the operation is non-blocking --- the message will be enqueued and sent in the background.
///
/// It is allowed to remove the subscription from its own callback, but not from the callback of another subscription.
cy_err_t cy_subscribe(struct cy_t* const       cy,
                      struct cy_topic_t* const topic,
                      struct cy_sub_t* const   sub,
                      const size_t             extent,
                      const uint64_t           tfer_id_timeout_us,
                      void (*const callback)(const struct cy_sub_event_t*));
void     cy_unsubscribe(struct cy_topic_t* const topic, struct cy_sub_t* const sub);

/// TRADEOFF: published messages are silently discarded until the topic is allocated.
cy_err_t cy_publish(struct cy_t* const        cy,
                    struct cy_topic_t* const  topic,
                    const uint64_t            tx_deadline_us,
                    const struct cy_payload_t payload);

// TODO FIXME getters/setters for the user-modifiable and user-readable fields.

#ifdef __cplusplus
}
#endif
