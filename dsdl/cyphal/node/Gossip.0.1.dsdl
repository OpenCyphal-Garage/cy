# Come back later.

uint64[3] value
# The interpretation of the value depends on the key.
#
# If the key name starts with a `/` and ends with `[0-9A-Za-z_]`, it means that the key names a topic; the values are:
#
#   1. The first value is the number of times the topic had to be moved due to subject-ID collisions.
#      We call it the eviction count. The allocated subject-ID for a topic is (hash+evictions)%6144,
#      unless it is a pinned topic, in which case the allocated subject-ID equals its hash.
#
#   2. The second value is an approximate logical age of the topic.
#      The logical age increases when the topic is gossiped, and when a valid transfer is received on it.
#      Topics with greater age win arbitration, thus ensuring stability of the network when new topics/nodes appear.
#
#   3. The third value is currently unused. Eventually, it may be used to report how the topic is used by the
#      publishing node: whether the node publishes and/or subscribes to the topic, etc.

uint64 key_hash
# The hash is computed as:
#
# - If the key names a pinned topic, which means it matches `^/([1-9][0-9]{0,4})$`, where the capture group
#   is the pinned subject-ID, then the hash is simply the pinned subject-ID. Pinned topic names always have the
#   canonical form, which can be seen from the pattern, meaning that for any subject-ID there is exactly one
#   pinned topic name encoding it.
#
# - Otherwise, key_hash=rapidhash(key).
#
# The reason the hash is here is that its computation is expensive, and we want to avoid recomputing it for every
# received gossip message, since there is necessarily a large number of them. We still need to transmit the full
# key because it is necessary for wildcard matching, and also for monitoring purposes (less important).

uint8 KEY_CAPACITY = 95
# Large keys increase the CRDT gossip traffic, so they are unlikely to be useful; plus they affect the memory
# footprint of protocol data structures. In practice, DDS and ROS topics longer than 80 characters are exceedingly
# rare, even though the actual limit there is 256 bytes.
#
# CAN FD networks should avoid keys longer than 14 bytes to avoid multi-frame heartbeats.
#
# The value is chosen such that the total size of the message is a multiple of 8 bytes,
# which simplifies memory aliasing of C structures.

utf8[<=KEY_CAPACITY] key
# An empty key is not a valid key.

@sealed
